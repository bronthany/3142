library(class)
library(caret)
library(devtools)
library(forcats)

## Splitting into Test and Training Sets
# Frequency

precovid <- quarterly.d1$quarter < 2020.3
d1.precovid <- quarterly.d1[precovid, ]
d1.covid <- quarterly.d1[!precovid,]

  # 80% split
set.seed(1)
data_partition1 <- createDataPartition(quarterly.d1$Claim_number, times = 1,p = 0.8,list = FALSE)
str(data_partition)
d1.train80 <- quarterly.d1[data_partition1,]
d1.test20 <- quarterly.d2[-data_partition1,]

#Severity
precovid<- quarterly.d2$quarter < 2020.3
d2.precovid <- quarterly.d2[precovid,]
d2.covid <- quarterly.d2[!precovid,]

  # 80% split
set.seed(1)
data_partition2 <- createDataPartition(quarterly.d2$Mean_claim_amount, times = 1,p = 0.8,list = FALSE)
d2.train80 <- quarterly.d2[data_partition2, ]


### K-FOLD CV for Time Series Data ###

# Function that calculates RMSE of final prediction
rootmse <- function(model, testset, trainingset){
  
  test <- predict(model, newdata = testset, type = "response")  # Prediction for Test set
  train <- predict(model, newdata = trainingset, type = "response")  # Prediction for Training set
  
  testset <- data.table(testset)
  testset <- testset[, pred := test   # Summarise predictions and actual claims by quarter for validation set
  ][, .(real_claims = sum(Claim_number), pred_claims = sum(pred), Date = last(Date)), by = .(quarter)]
  
  trainingset <- data.table(trainingset)
  trainingset <- trainingset[, pred := train   # Summarise predictions and actual claims by quarter for training set
  ][, .(real_claims = sum(Claim_number), pred_claims = sum(pred), Date = last(Date)), by = .(quarter)]
  
  rmse <- data.table("Training RMSE" = sqrt(mean((trainingset$real_claims - trainingset$pred_claims)^2)),
                     "Test RMSE" = sqrt(mean(testset$real_claims - testset$pred_claims)^2))
  return(rmse)
}
# Using K = 5, split data set into 5 folds.
Date <- unique(quarterly.d1$Date) # 20 quarters. 
split <- rep(1:5, each = 4, length.out = 20) # Using K = 5, split into 5 groups, with each being a full year
split <- cbind(Date, split)

kfold_freq <- merge(quarterly.d1, split, by = "Date")
kfold_sev <- merge(quarterly.d2, split, by = "Date")



###############################
##### FREQUENCY MODELLING #####
###############################

### ZERO-INFLATED NEGBINOM MODEL ###

## Backward selection - zeroinflated model (takes a long time)
full.model <- zeroinfl(Claim_number ~ vehicle_risk + vehicle_sales + road_deaths+
                         risk_state_name + policy_tenure + lag_petrol_price + lag_unemployment +
                         USDAUD + JPYAUD + CNYAUD + gold + petrol_price + manufacture +
                         lag_gold + unemployment + maintenance_index + region + q,
                       data = d1.train80,dist = "negbin",link= "logit")

step.model <- stepAIC(full.model, direction = "backward", 
                      trace = FALSE)
summary(step.model)

# Zero-inflated negative binomial model
zinb <- zeroinfl(Claim_number ~ vehicle_risk + lag_petrol_price + vehicle_sales
                  + policy_tenure + lag_gold + region + maintenance_index + q,
                   data = d1.train80, offset = log(exposure), dist = "negbin",link = "logit")
AIC(zinb) # 54433.55
rootmse(zinb, d1.test, d1.train)

# Run 5-fold Cross Validation
zinbCV <- data.table("Training RMSE" = numeric(), "Test RMSE" = numeric()) # Create empty table to store results
for(i in 1:5){
  training <- kfold_freq[which(kfold_freq$split <= i), ] 
  test <- kfold_freq[which(kfold_freq$split == i+1), ]
  
  model <- zeroinfl(Claim_number ~ vehicle_risk + lag_petrol_price + vehicle_sales
                    + policy_tenure + lag_gold + region + maintenance_index + q,
                    data = d1.train80, offset = log(exposure), dist = "negbin",link = "logit")
  print(summary(model))
  
  zinbCV <- rbind(zinbCV, rootmse(model, test, training))
}
zinbCV

# Visualisation for COVID prediction
zinb.covid <- predict(zinb, newdata = d1.covid, type = "response") # Testset prediction
zinb.precovid <- predict(zinb, newdata = d1.precovid, type = "response") # Training set prediction

zinb.covid <- d1.covid %>%
  mutate(pred = zinb.covid) %>%
  group_by(quarter) %>%
  summarise(real_claims = sum(Claim_number),
            pred_claims = sum(pred),
            Date = last(Date))

zinb.precovid <- d1.precovid %>%
  mutate(pred = zinb.precovid) %>%
  group_by(quarter) %>%
  summarise(real_claims = sum(Claim_number),
            pred_claims = sum(pred),
            Date = last(Date))

zinb.visual<- rbind(zinb.precovid, zinb.covid)
zinb.visual$Date <- as.Date(zinb.visual$Date)

ggplot(zinb.visual, aes(Date, pred_claims, group = 1, color = "Predicted")) +
  geom_rect(data = zinb.visual, 
            aes(xmin = as.Date("2020-09-01"), xmax = as.Date("2021-06-01"), ymin = 250, ymax = Inf, color = NULL), fill = "grey", alpha = 0.1, show.legend = FALSE) +
  geom_line() +
  geom_line(aes(y = real_claims, group = 1, color = "Actual")) +
  labs(y = "Claim Frequency", title = "Covid-19 Prediction") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

# RESULTS:
# AIC = 54433.55
# Variables in model: vehicle risk, lag petrol price, vehicle sales, policy tenure, lag gold, region, quarter, maintenance index
# #    Training RMSE Test RMSE
# 1:      13.55503  5.037127
# 2:      16.26040 14.596606
# 3:      19.11666  9.407096
# 4:      18.06297  5.555799


### POISSON REGRESSION ###
# Backward Selection

full.model.poisson <- glm(Claim_number ~ policy_tenure + vehicle_risk + sum_insured + year_of_manufacture + 
                            region + q + lag_petrol_price + vehicle_sales + loggas + lag_gold + road_deaths + unemployment + 
                           maintenance_index + state_level, data = d1.train80, 
                          family = "poisson", offset = log(exposure))
step.model.poi <- step(full.model.poisson, direction = "backward") # 56727
summary(step.model.poi)

# # Variables: Claim_number ~ policy_tenure + vehicle_risk + sum_insured + year_of_manufacture + region + q + lag_petrol_price + lag_gold + 
#   unemployment + state_level

# 5-fold CV
poissonCV <- data.table("Training RMSE" = numeric(), "Test RMSE" = numeric()) # Create empty table to store results
for(i in 1:4){
  training <- kfold_freq[which(kfold_freq$split <= i), ] 
  test <- kfold_freq[which(kfold_freq$split == i+1), ]
  
  model <- glm(formula = Claim_number ~ policy_tenure + vehicle_risk + sum_insured + 
                 year_of_manufacture + region + q + lag_petrol_price + lag_gold + 
                 unemployment + state_level, family = "poisson", data = training, 
               offset = log(exposure))
  
  print(summary(model))
  
  poissonCV <- rbind(poissonCV, rootmse(model, test, training))
}
poissonCV

# DISPERSION TEST
dispersiontest(step.model.poi, trafo = 1) # Overdispersed data. alpha = 0.2981353 > 0, p-value < 2.2e-16


# RESULTS:
# AIC = 56727
#   Training RMSE   Test RMSE
# 1:  2.770139e-06  27.90123
# 2:  3.621912e+00 103.52296
# 3:  1.133934e+01  41.53338
# 4:  1.321645e+01  48.91434
# Overdispersed data



### NEGATIVE BINOMIAL ###
# Backward Selection
full.model.nb <- glm.nb(Claim_number ~ policy_tenure + vehicle_risk + sum_insured + year_of_manufacture + 
                          region + q + lag_petrol_price + vehicle_sales + automotivegas + lag_gold + road_deaths + unemployment + 
                          maintenance_index + state_level, data = d1.train80, offset = log(exposure), control = glm.control(maxit=10000))
step.model.nb <- step(full.model.nb, direction = "backward") # 54423
summary(step.model.nb)

# # # Variables: Claim_number ~ policy_tenure + vehicle_risk + 
# sum_insured + year_of_manufacture + region + q + lag_petrol_price + 
#   lag_gold + unemployment + state_level


# 5-fold CV
nbCV <- data.table("Training RMSE" = numeric(), "Test RMSE" = numeric()) # Create empty table to store results
for(i in 1:4){
  training <- kfold_freq[which(kfold_freq$split <= i), ] 
  test <- kfold_freq[which(kfold_freq$split == i+1), ]
  
  model <- glm.nb(formula = Claim_number ~ policy_tenure + vehicle_risk + 
                    sum_insured + year_of_manufacture + region + q + lag_petrol_price + 
                    lag_gold + unemployment + state_level, data = training, 
                  control = glm.control(maxit = 10000), offset = log(exposure))
  
  print(summary(model))
  
  nbCV <- rbind(nbCV, rootmse(model, test, training))
}
nbCV

# Results:
# AIC: 54423
#    Training RMSE Test RMSE
# 1:      1.189836  28.45283
# 2:      4.051800  91.01293
# 3:     11.414171  42.45041
# 4:     13.301320  44.71127




##############################
##### SEVERITY MODELLING #####
##############################
