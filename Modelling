library(class)
library(caret)
library(devtools)
library(forcats)
library(dplyr)
library(ggplot2)
library(lubridate)
library(data.table)
library(tidyr)
library(actuar)
library(stringr)
library(gam)

theme_set(theme_bw())

## Splitting into Test and Training Sets
# Frequency

precovid <- quarterly.d1$quarter < 2020.3
d1.precovid <- quarterly.d1[precovid, ]
d1.covid <- quarterly.d1[!precovid,]

  # 80% split
set.seed(1)
data_partition1 <- createDataPartition(quarterly.d1$Claim_number, times = 1,p = 0.8,list = FALSE)
str(data_partition)
d1.train80 <- quarterly.d1[data_partition1,]
d1.test20 <- quarterly.d2[-data_partition1,]

#Severity
precovid<- quarterly.d2$quarter < 2020.3
d2.precovid <- quarterly.d2[precovid,]
d2.covid <- quarterly.d2[!precovid,]

  # 80% split
set.seed(1)
data_partition2 <- createDataPartition(quarterly.d2$Mean_claim_amount, times = 1,p = 0.8,list = FALSE)
d2.train80 <- quarterly.d2[data_partition2, ]


### K-FOLD CV for Time Series Data ###
# Function that calculates RMSE of final prediction
rootmse <- function(model, testset, trainingset){
  
  test <- predict(model, newdata = testset, type = "response")  # Prediction for Test set
  train <- predict(model, newdata = trainingset, type = "response")  # Prediction for Training set
  
  testset <- data.table(testset)
  testset <- testset[, pred := test   # Summarise predictions and actual claims by quarter for validation set
  ][, .(real_claims = sum(Claim_number), pred_claims = sum(pred), Date = last(Date)), by = .(quarter)]
  
  trainingset <- data.table(trainingset)
  trainingset <- trainingset[, pred := train   # Summarise predictions and actual claims by quarter for training set
  ][, .(real_claims = sum(Claim_number), pred_claims = sum(pred), Date = last(Date)), by = .(quarter)]
  
  rmse <- data.table("Training RMSE" = sqrt(mean((trainingset$real_claims - trainingset$pred_claims)^2)),
                     "Test RMSE" = sqrt(mean(testset$real_claims - testset$pred_claims)^2))
  return(rmse)
}

# Using K = 5, split data set into 5 folds.
quarter <- unique(quarterly.d1$quarter) # 20 quarters. 
split <- data.frame("split" = rep(1:5, each = 4, length.out = 20)) # Using K = 5, split into 5 groups, with each being a full year
split <- cbind(quarter, split)

kfold_freq <- merge(quarterly.d1, split, by = "quarter")
kfold_sev <- merge(quarterly.d2, split, by = "quarter")



###############################
##### FREQUENCY MODELLING #####
###############################

# Function that calculates RMSE of final prediction - Frequency
rootmse <- function(model, testset, trainingset){
  
  test <- predict(model, newdata = testset, type = "response")  # Prediction for Test set
  train <- predict(model, newdata = trainingset, type = "response")  # Prediction for Training set
  
  testset <- data.table(testset)
  testset <- testset[, pred := test   # Summarise predictions and actual claims by quarter for validation set
  ][, .(real_claims = sum(Claim_number), pred_claims = sum(pred), Date = last(Date)), by = .(quarter)]
  
  trainingset <- data.table(trainingset)
  trainingset <- trainingset[, pred := train   # Summarise predictions and actual claims by quarter for training set
  ][, .(real_claims = sum(Claim_number), pred_claims = sum(pred), Date = last(Date)), by = .(quarter)]
  
  rmse <- data.table("Training RMSE" = sqrt(mean((trainingset$real_claims - trainingset$pred_claims)^2)),
                     "Test RMSE" = sqrt(mean(testset$real_claims - testset$pred_claims)^2))
  return(rmse)
}

### ZERO-INFLATED NEGBINOM MODEL ###

## Backward selection - zeroinflated model (takes a long time)
full.model <- zeroinfl(Claim_number ~ vehicle_risk + vehicle_sales + road_deaths+
                         risk_state_name + policy_tenure + lag_petrol_price + lag_unemployment +
                         USDAUD + JPYAUD + CNYAUD + gold + petrol_price + manufacture +
                         lag_gold + unemployment + maintenance_index + region + q,
                       data = d1.train80,dist = "negbin",link= "logit")

step.model <- stepAIC(full.model, direction = "backward", 
                      trace = FALSE)
summary(step.model)

# Zero-inflated negative binomial model
zinb <- zeroinfl(Claim_number ~ vehicle_risk + lag_petrol_price + vehicle_sales
                  + policy_tenure + lag_gold + region + maintenance_index + q,
                   data = d1.train80, offset = log(exposure), dist = "negbin",link = "logit")
AIC(zinb) # 54433.55
rootmse(zinb, d1.test, d1.train)

# Run 5-fold Cross Validation
zinbCV <- data.table("Training RMSE" = numeric(), "Test RMSE" = numeric()) # Create empty table to store results
for(i in 1:5){
  training <- kfold_freq[which(kfold_freq$split <= i), ] 
  test <- kfold_freq[which(kfold_freq$split == i+1), ]
  
  model <- zeroinfl(Claim_number ~ vehicle_risk + lag_petrol_price + vehicle_sales
                    + policy_tenure + lag_gold + region + maintenance_index + q,
                    data = d1.train80, offset = log(exposure), dist = "negbin",link = "logit")
  print(summary(model))
  
  zinbCV <- rbind(zinbCV, rootmse(model, test, training))
}
zinbCV
print(mean(zinbCV$`Test RMSE`[1:3]))
print(mean(zinbCV$`Test RMSE`[4]))

# Visualisation for COVID prediction
zinb.covid <- predict(zinb, newdata = d1.covid, type = "response") # Testset prediction
zinb.precovid <- predict(zinb, newdata = d1.precovid, type = "response") # Training set prediction

zinb.covid <- d1.covid %>%
  mutate(pred = zinb.covid) %>%
  group_by(quarter) %>%
  summarise(real_claims = sum(Claim_number),
            pred_claims = sum(pred),
            Date = last(Date))

zinb.precovid <- d1.precovid %>%
  mutate(pred = zinb.precovid) %>%
  group_by(quarter) %>%
  summarise(real_claims = sum(Claim_number),
            pred_claims = sum(pred),
            Date = last(Date))

zinb.visual<- rbind(zinb.precovid, zinb.covid)
zinb.visual$Date <- as.Date(zinb.visual$Date)

ggplot(zinb.visual, aes(Date, pred_claims, group = 1, color = "Predicted")) +
  geom_rect(data = zinb.visual, 
            aes(xmin = as.Date("2020-09-01"), xmax = as.Date("2021-06-01"), ymin = 250, ymax = Inf, color = NULL), fill = "grey", alpha = 0.1, show.legend = FALSE) +
  geom_line() +
  geom_line(aes(y = real_claims, group = 1, color = "Actual")) +
  labs(y = "Claim Frequency", title = "Covid-19 Prediction") +
  theme(axis.title.x = element_text(margin = margin(t = 10), size = 10),
        axis.title.y = element_text(margin = margin(r = 10), size = 10),
        plot.title = element_text(size = 10, hjust = 0.5), axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), 
        legend.title = element_blank())

# RESULTS:
# AIC = 54433.55
# Variables in model: vehicle risk, lag petrol price, vehicle sales, policy tenure, lag gold, region, quarter, maintenance index
# #    Training RMSE Test RMSE
# 1:      13.55503  5.037127
# 2:      16.26040 14.596606
# 3:      19.11666  9.407096
# 4:      18.06297  5.555799


### POISSON REGRESSION ###
# Backward Selection

full.model.poisson <- glm(Claim_number ~ policy_tenure + vehicle_risk + sum_insured + year_of_manufacture + 
                            region + seasonality + lag_petrol_price + vehicle_sales + loggas + lag_gold + road_deaths + unemployment + 
                           maintenance_index + state_level, data = d1.train80, 
                          family = "poisson", offset = log(exposure))
step.model.poi <- step(full.model.poisson, direction = "backward") # 56727
summary(step.model.poi)

# # Variables: Claim_number ~ policy_tenure + vehicle_risk + sum_insured + year_of_manufacture + region + seasonality + lag_petrol_price + lag_gold + 
#   unemployment + state_level

# 5-fold CV
poissonCV <- data.table("Training RMSE" = numeric(), "Test RMSE" = numeric()) # Create empty table to store results
for(i in 1:4){
  training <- kfold_freq[which(kfold_freq$split <= i), ] 
  test <- kfold_freq[which(kfold_freq$split == i+1), ]
  
  model <- glm(formula = Claim_number ~ policy_tenure + vehicle_risk + sum_insured + 
                 year_of_manufacture + region + q + lag_petrol_price + lag_gold + 
                 unemployment + state_level, family = "poisson", data = training, 
               offset = log(exposure))
  
  print(summary(model))
  
  poissonCV <- rbind(poissonCV, rootmse(model, test, training))
}
poissonCV
print(mean(poissonCV$`Test RMSE`[1:3]))
print(mean(poissonCV$`Test RMSE`[4]))

# DISPERSION TEST
dispersiontest(step.model.poi, trafo = 1) # Overdispersed data. alpha = 0.2981353 > 0, p-value < 2.2e-16


# RESULTS:
# AIC = 56727
#   Training RMSE   Test RMSE
# 1:  2.770139e-06  27.90123
# 2:  3.621912e+00 103.52296
# 3:  1.133934e+01  41.53338
# 4:  1.321645e+01  48.91434
# Overdispersed data



### NEGATIVE BINOMIAL ###
# Backward Selection
full.model.nb <- glm.nb(Claim_number ~ policy_tenure + vehicle_risk + sum_insured + year_of_manufacture + 
                          region + q + lag_petrol_price + vehicle_sales + automotivegas + lag_gold + road_deaths + unemployment + 
                          maintenance_index + state_level, data = d1.train80, offset = log(exposure), control = glm.control(maxit=10000))
step.model.nb <- step(full.model.nb, direction = "backward") # 54423
summary(step.model.nb)

# # # Variables: Claim_number ~ policy_tenure + vehicle_risk + 
# sum_insured + year_of_manufacture + region + q + lag_petrol_price + 
#   lag_gold + unemployment + state_level


# 5-fold CV
nbCV <- data.table("Training RMSE" = numeric(), "Test RMSE" = numeric()) # Create empty table to store results
for(i in 1:4){
  training <- kfold_freq[which(kfold_freq$split <= i), ] 
  test <- kfold_freq[which(kfold_freq$split == i+1), ]
  
  model <- glm.nb(formula = Claim_number ~ policy_tenure + vehicle_risk + 
                    sum_insured + year_of_manufacture + region + q + lag_petrol_price + 
                    lag_gold + unemployment + state_level, data = training, 
                  control = glm.control(maxit = 10000), offset = log(exposure))
  
  print(summary(model))
  
  nbCV <- rbind(nbCV, rootmse(model, test, training))
}
nbCV
print(mean(nbCV$`Test RMSE`[1:3]))
print(mean(nbCV$`Test RMSE`[4]))

# Results:
# AIC: 54423
#    Training RMSE Test RMSE
# 1:      1.189836  28.45283
# 2:      4.051800  91.01293
# 3:     11.414171  42.45041
# 4:     13.301320  44.71127




##############################
##### SEVERITY MODELLING #####
##############################

# Function that calculates RMSE of final prediction - Severity
rootmse_sev <- function(model, testset, trainingset){
  
  test <- predict(model, newdata = testset, type = "response")  # Prediction for Test set
  train <- predict(model, newdata = trainingset, type = "response")  # Prediction for Training set
  
  testset <- data.table(testset)
  testset <- testset[, pred := test   # Summarise predictions and actual claims by quarter for validation set
  ][, .(real_size = mean(Mean_claim_amount), pred_size = mean(pred), Date = last(Date)), by = .(quarter)]
  
  trainingset <- data.table(trainingset)
  trainingset <- trainingset[, pred := train   # Summarise predictions and actual claims by quarter for training set
  ][, .(real_size = mean(Mean_claim_amount), pred_size = mean(pred), Date = last(Date)), by = .(quarter)]
  
  rmse <- data.table("Training RMSE" = sqrt(mean((trainingset$real_size - trainingset$pred_size)^2)),
                     "Test RMSE" = sqrt(mean(testset$real_size - testset$pred_size)^2))
  return(rmse)
}

### GAMMA GAM MODEL ###

## Backward selection - Gamma GAM model 
full.model.gam <- gam(Mean_claim_amount ~ state_group + sum_insured + vehicle_risk + QuarterlyClaim + year_of_manufacture + petrol_price + road_deaths +  
               maintenance_index + USDAUD + season + region, data = d2.train80, family = Gamma(link = "log"))
               
scope_list = list("state_group"=~1+state_group,"sum_insured"=~1+sum_insured+s(sum_insured,3)+s(sum_insured,4)+s(sum_insured,5)+s(sum_insured,8)+s(sum_insured,9)+s(sum_insured,10)+s(sum_insured,11),
                  "vehicle_risk"=~1+vehicle_risk,
                  "year_of_manufacture"=~1+year_of_manufacture+s(year_of_manufacture,3)+s(year_of_manufacture,4)+s(year_of_manufacture,5)+s(year_of_manufacture,10)+s(year_of_manufacture,11)+s(year_of_manufacture,12)+s(year_of_manufacture,13),
                  "petrol_price"=~1+petrol_price+s(petrol_price,3)+s(petrol_price,4)+s(petrol_price,5),
                  "road_deaths"=~1+road_deaths+s(road_deaths,3)+s(road_deaths,4)+s(road_deaths,5),
                  "USDAUD"=~1+USDAUD+s(USDAUD,3)+s(USDAUD,4)+s(USDAUD,5),
                  "maintenance_index"=~1+maintenance_index+s(maintenance_index,3)+s(maintenance_index,4)+s(maintenance_index,5),
                  "QuarterlyClaim"=~1+QuarterlyClaim+s(QuarterlyClaim,3)+s(QuarterlyClaim,4)+s(QuarterlyClaim,5),
                  "season"=~1+season, "region"=~1+region)

step.model.gam <- step.Gam(full.model.gam, scope = scope_list, direction="both")
summary(step.model.gam)

# Gamma GAM Model
GAMmod <- gam(Mean_claim_amount ~ state_group + s(sum_insured, 9) + vehicle_risk + s(year_of_manufacture, 3) + petrol_price + maintenance_index + region, 
        family = Gamma(link = "log"), data = d2.train80, trace = FALSE)
AIC(GAMmod) # 98737.24
rootmse_sev(GAMmod, d1.covid, d1.precovid)
#Train RMSE: 356.10
#Test RMSE : 2.76

# Run 5-fold Cross Validation
gamCV <- data.table("Training RMSE" = numeric(), "Test RMSE" = numeric()) # Create empty table to store results
for(i in 1:4){
  training <- kfold_sev[which(kfold_sev$split <= i), ] 
  test <- kfold_sev[which(kfold_sev$split == i+1), ]
  
  model <- gam(Mean_claim_amount ~ state_group + s(sum_insured, 9) + vehicle_risk + s(year_of_manufacture,3) + petrol_price + maintenance_index + region, 
               data = training, family = Gamma(link = "log"))
  #print(summary(model))
  
  gamCV <- rbind(gamCV, rootmse_sev(model, test, training))
}
gamCV
print(mean(gamCV$`Test RMSE`[1:3]))
print(mean(gamCV$`Test RMSE`[4]))

# Visualisation for COVID prediction
gam.covid <- predict(GAMmod, newdata = d2.covid, type = "response") # Testset prediction
gam.precovid <- predict(GAMmod, newdata = d2.precovid, type = "response") # Training set prediction

gam.covid <- d2.covid %>%
  mutate(pred = gam.covid) %>%
  group_by(quarter) %>%
  summarise(real_size = mean(Mean_claim_amount),
            pred_size = mean(pred),
            Date = last(Date))

gam.precovid <- d2.precovid %>%
  mutate(pred = gam.precovid) %>%
  group_by(quarter) %>%
  summarise(real_size = mean(Mean_claim_amount),
            pred_size = mean(pred),
            Date = last(Date))

gam.visual<- rbind(gam.precovid, gam.covid)
gam.visual$Date <- as.Date(gam.visual$Date)

ggplot(gam.visual, aes(Date, pred_size, group = 1, color = "Predicted")) +
  geom_rect(data = gam.visual, 
            aes(xmin = as.Date("2020-09-01"), xmax = as.Date("2021-06-01"), ymin = 4000, ymax = Inf, color = NULL), fill = "grey", alpha = 0.1, show.legend = FALSE) +
  geom_line() +
  geom_line(aes(y = real_size, group = 1, color = "Actual")) +
  labs(y = "Claim Severity", 
       title = "COVID-19 Prediction") +
  theme(axis.title.x = element_text(margin = margin(t = 10), size = 10),
        axis.title.y = element_text(margin = margin(r = 10), size = 10),
        plot.title = element_text(size = 10, hjust = 0.5), axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1), 
        legend.title = element_blank())
        
# RESULTS:
# AIC = 98737.24
# Variables in model: state group, sum insured, vehicle risk, year of manufacture, petrol price, maintenance index, region
# #    Training RMSE Test RMSE
# 1:      218.6169  387.7916
# 2:      238.7924  164.0737
# 3:      234.7318  101.1698
# 4:      328.7131  395.0547


### LOG-LINKED GAUSSIAN REGRESSION ###
# Backward Selection

full.model.gauss <- glm(Mean_claim_amount ~ state_group + sum_insured + vehicle_risk + CPI_index + QuarterlyClaim + year_of_manufacture + petrol_price + road_deaths +  maintenance_index 
              + USDAUD + season + region, data = d2.train80, family = gaussian(link = "log"))
              
step.model.gauss <- step(full.model.gauss, direction = "both") # 105895.7
summary(step.model.gauss)

# Variables: state group, sum insured, vehicle risk, year of manufacture, maintenance index, region

# 5-fold CV
gaussianCV <- data.table("Training RMSE" = numeric(), "Test RMSE" = numeric()) # Create empty table to store results
for(i in 1:4){
  training <- kfold_sev[which(kfold_sev$split <= i), ] 
  test <- kfold_sev[which(kfold_sev$split == i+1), ]
  
  model <- glm(Mean_claim_amount ~ state_group + sum_insured + vehicle_risk + year_of_manufacture + maintenance_index + region, 
               data = training, family = gaussian(link = "log"))
  print(summary(model))
  
  gaussianCV <- rbind(gaussianCV, rootmse_sev(model, test, training))
}
gaussianCV
print(mean(gaussianCV$`Test RMSE`[1:3]))
print(mean(gaussianCV$`Test RMSE`[4]))


# RESULTS:
# AIC = 105895.7
##    Training RMSE Test RMSE
# 1:      259.3058  646.7083
# 2:      265.5724  609.7830
# 3:      361.3940  885.1748
# 4:      372.1005  100.0105


### GAMMA REGRESSION ###
# Backward Selection

full.model.gamma <- glm(Mean_claim_amount ~ state_group + sum_insured + vehicle_risk + CPI_index + year_of_manufacture + petrol_price + vehicle_sales + road_deaths +  maintenance_index 
              + USDAUD + season + region, data = d2.train80, family = Gamma(link = "log"))
              
step.model.gamma <- step(full.model.gamma, direction = "both") # 98875.28
summary(step.model.gamma)

# Variables: state group, sum insured, vehicle risk, year of manufacture, petrol price, maintenance index, region

# 5-fold CV
gammaCV <- data.table("Training RMSE" = numeric(), "Test RMSE" = numeric()) # Create empty table to store results
for(i in 1:4){
  training <- kfold_sev[which(kfold_sev$split <= i), ] 
  test <- kfold_sev[which(kfold_sev$split == i+1), ]
  
  model <- glm(Mean_claim_amount ~ state_group + sum_insured + vehicle_risk + year_of_manufacture + maintenance_index + region, 
               data = training, family = Gamma(link = "log"))
  print(summary(model))
  
  gammaCV <- rbind(gammaCV, rootmse_sev(model, test, training))
}
gammaCV
print(mean(gammaCV$`Test RMSE`[1:3]))
print(mean(gammaCV$`Test RMSE`[4]))


# RESULTS:
# AIC = 98875.28
##     Training RMSE Test RMSE
# 1:      188.6984  268.1837
# 2:      256.8484  305.3437
# 3:      421.6380  154.8868
# 4:      495.6167  185.6869




